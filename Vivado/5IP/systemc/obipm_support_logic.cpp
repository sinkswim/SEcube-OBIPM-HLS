// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2016.4
// Copyright (C) 1986-2017 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

#include "obipm_support_logic.h"
#include "AESL_pkg.h"

using namespace std;

namespace ap_rtl {

const bool obipm_support_logic::ap_const_boolean_1 = true;
const sc_logic obipm_support_logic::ap_const_logic_0 = sc_dt::Log_0;
const sc_logic obipm_support_logic::ap_const_logic_1 = sc_dt::Log_1;
const sc_lv<5> obipm_support_logic::ap_const_lv5_0 = "00000";

obipm_support_logic::obipm_support_logic(sc_module_name name) : sc_module(name), mVcdFile(0) {

    SC_METHOD(thread_ack_ip);
    sensitive << ( ack_internal );

    SC_METHOD(thread_ack_ip_ap_vld);

    SC_METHOD(thread_acked);
    sensitive << ( ack_internal );

    SC_METHOD(thread_acked_ap_vld);

    SC_METHOD(thread_interrupt_cpu);
    sensitive << ( interrupt_internal );

    SC_METHOD(thread_interrupt_cpu_ap_vld);

    SC_METHOD(thread_irq);
    sensitive << ( interrupt_ip );

    SC_METHOD(thread_irq_ap_vld);

    static int apTFileNum = 0;
    stringstream apTFilenSS;
    apTFilenSS << "obipm_support_logic_sc_trace_" << apTFileNum ++;
    string apTFn = apTFilenSS.str();
    mVcdFile = sc_create_vcd_trace_file(apTFn.c_str());
    mVcdFile->set_time_unit(1, SC_PS);
    if (1) {
#ifdef __HLS_TRACE_LEVEL_PORT_HIER__
    sc_trace(mVcdFile, ack_ip, "(port)ack_ip");
    sc_trace(mVcdFile, ack_ip_ap_vld, "(port)ack_ip_ap_vld");
    sc_trace(mVcdFile, interrupt_ip, "(port)interrupt_ip");
    sc_trace(mVcdFile, interrupt_cpu, "(port)interrupt_cpu");
    sc_trace(mVcdFile, interrupt_cpu_ap_vld, "(port)interrupt_cpu_ap_vld");
    sc_trace(mVcdFile, interrupt_internal, "(port)interrupt_internal");
    sc_trace(mVcdFile, ack_internal, "(port)ack_internal");
    sc_trace(mVcdFile, acked, "(port)acked");
    sc_trace(mVcdFile, acked_ap_vld, "(port)acked_ap_vld");
    sc_trace(mVcdFile, irq, "(port)irq");
    sc_trace(mVcdFile, irq_ap_vld, "(port)irq_ap_vld");
#endif

    }
}

obipm_support_logic::~obipm_support_logic() {
    if (mVcdFile) 
        sc_close_vcd_trace_file(mVcdFile);

}

void obipm_support_logic::thread_ack_ip() {
    ack_ip = ack_internal.read();
}

void obipm_support_logic::thread_ack_ip_ap_vld() {
    if (esl_seteq<1,1,1>(ap_const_boolean_1, ap_const_boolean_1)) {
        ack_ip_ap_vld = ap_const_logic_1;
    } else {
        ack_ip_ap_vld = ap_const_logic_0;
    }
}

void obipm_support_logic::thread_acked() {
    acked = (!ack_internal.read().is_01() || !ap_const_lv5_0.is_01())? sc_lv<1>(): sc_lv<1>(ack_internal.read() != ap_const_lv5_0);
}

void obipm_support_logic::thread_acked_ap_vld() {
    if (esl_seteq<1,1,1>(ap_const_boolean_1, ap_const_boolean_1)) {
        acked_ap_vld = ap_const_logic_1;
    } else {
        acked_ap_vld = ap_const_logic_0;
    }
}

void obipm_support_logic::thread_interrupt_cpu() {
    interrupt_cpu = interrupt_internal.read();
}

void obipm_support_logic::thread_interrupt_cpu_ap_vld() {
    if (esl_seteq<1,1,1>(ap_const_boolean_1, ap_const_boolean_1)) {
        interrupt_cpu_ap_vld = ap_const_logic_1;
    } else {
        interrupt_cpu_ap_vld = ap_const_logic_0;
    }
}

void obipm_support_logic::thread_irq() {
    irq = (!interrupt_ip.read().is_01() || !ap_const_lv5_0.is_01())? sc_lv<1>(): sc_lv<1>(interrupt_ip.read() != ap_const_lv5_0);
}

void obipm_support_logic::thread_irq_ap_vld() {
    if (esl_seteq<1,1,1>(ap_const_boolean_1, ap_const_boolean_1)) {
        irq_ap_vld = ap_const_logic_1;
    } else {
        irq_ap_vld = ap_const_logic_0;
    }
}

}

